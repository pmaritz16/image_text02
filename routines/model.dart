// 2024-11-03

import 'package:flutter/material.dart';
import 'dart:io';
import 'dart:ui' as UI;
import 'package:image/image.dart' as DI;
import 'dart:isolate';
import 'package:async/async.dart';
import 'package:flutter/services.dart';
//import 'dart:convert';

import 'package:image_text02/pm_utilities/pm_constants.dart';
import 'package:image_text02/pm_utilities/pm_flutter.dart';
import 'package:image_text02/pm_utilities/pm_dartUtils.dart';

import 'package:image_text02/routines/app_common.dart';
import 'package:image_text02/routines/IEImage_and_GridSquare.dart';
import 'package:image_text02/routines/make_thumbs.dart';

class Model extends ChangeNotifier {
  // holds shared data items for all pages/routines and routines that operate of them
  //
  final PMR p = PMR(className: 'Model', defaultLevel: 0);

  int baseNumber = 0; // base for renumbering file names
  late bool clearImageCache; // toggle to control cache clear
  String currentDirPath = kStartingDirectory;
  late String currentFilePath;
  int currentIndex = -1;
  IEImage? currentIEImage;
  Map contextAndRoute = {}; //used when moving to new page
  List<String> directories = [];
  List<FileItem> fileItems = [];
  int end = 0; // end of current page
  late StreamQueue events; // associated with thumb making isolate
  RegExp? filter; // regexp use to filter file names
  String filterString = '';
  bool isolateSpawned = false;
  List moveDirectories =
      []; // structure holding directory names to which files can be moved
  String newBaseFileName = ''; // used for general rename
  int numToBeDeleted = 0; // number of files flagged for deletion
  int numToBeMoved = 0; // number of files flagged for move
  int pageSize = kInitialPageSize;
  bool pxlNames =
      false; // flag indicating whether names are generated by Pixel camera
  late ReceivePort port; // isolate
  late int requestedInterval; // requested seconds for slide show
  List<int> requestStack =
      []; // stack of page starts for which thumbs have been requested
  int start = 0; // start index of current page
  late SendPort sendPort; // isolate
  late int slideShowInterval;

  bool initialize() {
    List<Map>? dirFiles;
    baseNumber = 0;
    clearImageCache = false;
    currentIndex = 0;
    directories = [];
    fileItems = [];
    moveDirectories = [];
    numToBeDeleted = 0;
    numToBeMoved = 0;
    pxlNames = false;
    requestStack = [];
    requestedInterval = kDefaultInterval;
    slideShowInterval = -1;

    for (String name in kMoveTargets) addMoveFileItem(name, '');

    dirFiles = pmListDir(currentDirPath);
    if (dirFiles != null) {
      //p.logF('initializing fileItems from dirFiles.length = ${dirFiles.length}');
      //p.logF('filter = ${filter == null ? 'null' : filter.toString()}');
      for (Map entry in dirFiles) {
        if (entry[kpmDir]) {
          directories.add(entry[kpmFileName]);
          continue;
        }
        if (PMParsePath(entry[kpmFileName]).ext.toLowerCase() != 'jpg')
          continue;
        if (filter != null) if (!filter!.hasMatch(entry[kpmFileName].toUpperCase())) continue;
        fileItems.add(
            FileItem(pmJoinPathToName(currentDirPath, entry[kpmFileName])));
      }
      //p.logF('matched ${fileItems.length} files');
      notify();
      return true;
    } else {
      p.logF('tried to initialize fileItems, dirFiles = null');
      return false;
    }// signal error of directory empty
  }

  addMoveFileItem(String name, String moniker) {
    PMParsePath pp = PMParsePath(currentDirPath);
    moveDirectories
        .add(MoveTargets(pmJoinPathToName(pp.pathTo, name), moniker));
  }

  int checkPageStart(int ps) {
    return ps < 0 ? 0 : ps;
  }

  int checkPageEnd(int pe) {
    return pe > fileItems.length ? fileItems.length : pe;
  }

  String currentNameForFilter() {
    String s = fileItems[currentIndex].name;
    int i = s.length - 1;
    while (i >= 0 && pmSubstring(s, start: i) != "-") {
      i--;
    }
    return i < 0 ? s : pmSubstring(s, len: i);
  }

  decreaseInterval() {
    requestedInterval = (requestedInterval / 2).floor();
    if (requestedInterval < 1) requestedInterval = 1;
    notify();
  }

  deleteImages() {
    if (numToBeDeleted == 0) return;
    for (int i = fileItems.length - 1; i >= 0; i--) {
      if (fileItems[i].toBeDeleted) {
        //p.logR('deleting $i, ${fileItems[i].name}', level: 0);
        pmDeleteEntry(fileItems[i].fullPath);
        fileItems.removeAt(i);
        if (i < currentIndex) currentIndex--;
      }
    }

    resetRequestFlags();
    setPageStartEnd();
    notify();
  }

  flagForDeletion(int i) {
    if (fileItems[i].toBeDeleted) {
      numToBeDeleted--;
      fileItems[i].toBeDeleted = false;
    } else {
      numToBeDeleted++;
      fileItems[i].toBeDeleted = true;
    }
    notify();
  }

  String getRootName(String str) {
    RegExp exp = RegExp(r'[0-9]*$');
    RegExpMatch? match = exp.firstMatch(str);
    if (match != null) {
      String? s = match[0];
      int d = s!.length > 3 ? 1 : 0;
      String? ss = str.substring(0, str.length - s.length+d);
      return ss;
    }
    return str;
  }

  groupCopy(String s, int j) {
    //p.logF('groupCopy: "$s", $j');
    if (pmNil(s)) return;
    String t = '^$s.*';
    RegExp localFilter = RegExp(t);
    for (int i = 0; i < fileItems.length; i++) {
      if (localFilter.hasMatch(fileItems[i].name)) {
        moveCopyFile(fileItems[i], j, false);
      }
    }
  }

  groupDelete(String s) {
    //p.logF('deleteF: $s');
    if (pmNil(s)) return;
    String t = '^$s.*';
    RegExp localFilter = RegExp(t);
    for (int i = fileItems.length - 1; i >= 0; i--) {
      if (localFilter.hasMatch(fileItems[i].name)) {
        //p.logF('deleting: ${fileItems[i].name}');
        pmDeleteEntry(fileItems[i].fullPath);
        fileItems.removeAt(i);
      }
    }

    resetRequestFlags();
    setPageStartEnd();
    jumpBackToPrev();
    jumpDownToNext(); // has effect of setting index at start of next group
    notify();
  }

  groupMove(String s) {
    groupCopy(s, 0);
    groupDelete(s);
  }

  increaseInterval() {
    requestedInterval = requestedInterval * 2;
    notify();
  }

  initiateThumbs() {
    //
    pushRequest(int ps) {
      if (ps < 0 || ps > fileItems.length) return;
      fileItems[start].thumbsRequested = true;
      requestStack.add(ps);
      //p.logF('pushed new request for $ps, $requestStack');
    }

    // has a request for the page already been made?, if so, just return
    if (fileItems[start].thumbsRequested) return;

    int requestLength = requestStack.length;

    // request thumbs for two pages down
    pushRequest(start + 2 * pageSize);
    // for page before
    pushRequest(start - pageSize);
    // request for one page down
    pushRequest(start + pageSize);
    // and now the actual request
    pushRequest(start);

    // are there requests on the stack?
    if (requestStack.length > 0) {
      // were there requests underway at time of entry, if not call makeThumbs
      if (requestLength == 0) makeThumbs();
    }
  }

  int count = 1; // used to track for debug purposes

  jumpToAbsolute(int i) {
    stopSlideShow();
    jumpToOffset(i - currentIndex);
  }

  jumpToOffset(int offset) {
    currentIndex += offset;
    //p.logF('model currentIndex $currentIndex');
    setPageStartEnd();
    initiateThumbs();
    //p.logF('move to: $currentIndex, $start - $end');
    notify();
  }

  jumpToFilter(String s) {
    if (pmNil(s)) return;
    String t = '^$s.*';
    RegExp localFilter = RegExp(t);
    int i;
    for (i = 0; i < fileItems.length; i++) {
      if (localFilter.hasMatch(fileItems[i].name)) {
        break;
      }
    }
    if (i < fileItems.length) jumpToAbsolute(i);
  }

  jumpDownToNext() {
    String currentRoot = getRootName(fileItems[currentIndex].name);
    int i = currentIndex + 1;
    while (i < fileItems.length) {
      String rootI = getRootName(fileItems[i].name);
      if (currentRoot != rootI) break;
      i++;
    }
    jumpToAbsolute(i);
  }

  jumpBackToPrev() {
    String currentRoot = getRootName(fileItems[currentIndex].name);
    int i = currentIndex - 1;
    while (i >= 0) {
      String rootI = getRootName(fileItems[i].name);
      if (currentRoot != rootI) break;
      i--;
    }
    if (i < 0)
      jumpToAbsolute(0);
    else {
      currentRoot = getRootName(fileItems[i].name);
      while (i >= 0) {
        String rootI = getRootName(fileItems[i].name);
        if (currentRoot != rootI) break;
        i--;
      }
      i++;
      jumpToAbsolute(i);
    }
  }

  int thumbsActive = 0;

  makeThumbs() async {
    //p.logF('thumbsActive enter: $thumbsActive');
    thumbsActive++;
    // thumbs are made in a separate isolate, which gets spawned once at program start

    if (!isolateSpawned) {
      // initialize the separate isolate
      port = ReceivePort();
      await Isolate.spawn(readAndMakeThumb, port.sendPort);
      events = StreamQueue<dynamic>(port);
      sendPort = await events.next;
      isolateSpawned = true;
    }

    //int c = count++; // used for debug
    // get the request at top of stack
    int stackLength = requestStack.length;
    int ps = requestStack[stackLength - 1];
    //p.logF(
    //  'entering makeThumbs: #$c, start@$ps - stack=$requestStack|${requestStack.length} ');
    // and process that page

    int i = ps;
    while (i < checkPageEnd(ps + pageSize)) {
      // examine next filename to be have thumb made
      if (fileItems[i].isolateRequestStatus < 0)
      // i.e. no request yet made for this file
      {
        int j = -1;
        Map result = {};

        callBack(UI.Image imageUI) {
          fileItems[j].thumbnail = RawImage(image: imageUI);
          fileItems[j].isolateRequestStatus =
              1; // i.e. set status to thumb complete
          fileItems[j].width = result[kpmWidth];
          fileItems[j].height = result[kpmHeight];
          fileItems[j].size = result[kpmSize];
          //p.logF('thumb set: $j, ${fileItems[j].name}');
          i = ps; // reset to start of page, in case files have been deleted/moved
          notify();
        }

        //p.logF('requesting: $i, ${fileItems[i].name}');
        fileItems[i].isolateRequestStatus = 0; // set status to pending
        sendPort.send(fileItems[i].fullPath);
        result = await events.next;
        p.logR(
            'got thumb for ${result[kpmFileName]}, len: ${result[kpmData].length}');
        // indices may have been altered during the await, so look up correct index for the thumb
        // and curry it in to the callback
        if (result[kpmData] != null) {
          j = pmListFind(fileItems, result[kpmFileName],
              xform: (x) => x.fullPath);
          if (j >= 0) UI.decodeImageFromList(result[kpmData], callBack);
        }
      } else {
        // i.e. thumb is pending or complete
        i++;
      }
      // now check to see if a new request has been pushed while thumb was being made
      if (requestStack.length > stackLength) {
        await makeThumbs(); // yes, complete that request first, and then resume
      }
    }
    // request is now complete
    //p.logF('request complete: #$c - $requestStack|${requestStack.length} ');

    if (requestStack.length > 0)
      requestStack
          .removeAt(requestStack.length - 1); // pop the request off the stack
    //p.logF('stack length = 0 !!');
    // are there still requests on the stack
    if (requestStack.length > 0) await makeThumbs(); // yes, do request
    //p.logF('exiting makeThumbs: #$c');
    thumbsActive--;
    //p.logF('thumbsActive exit: $thumbsActive');
    if (thumbsActive == 0) notify();
  }

  moveCopyFile(FileItem fi, int ri, bool move) {
    //p.logF('moveCopy: ${fi.name} $ri, $move');
    String np = moveDirectories[ri].newPath;
    String newFullPath = pmJoinPathToName(np, fi.fileName);
    Directory(np).createSync(recursive: true);
    File file = File(fi.fullPath);
    if (move) {
      file.renameSync(newFullPath);
    } else {
      File newFile = File(newFullPath);
      newFile.writeAsBytesSync(file.readAsBytesSync());
    }
  }

  moveCopyFiles(bool move) {
    for (int i = fileItems.length - 1; i >= 0; i--) {
      FileItem fi = fileItems[i];
      if (fi.toBeDeleted) continue;
      //p.logR('rename? $i, ${fileItems[i].name}: ${fileItems[i].moveIndex}');
      int ri = fi.moveIndex;
      if (ri >= 0) {
        moveCopyFile(fi, ri, move);
        fileItems.removeAt(i);
        if (i < currentIndex) currentIndex--;
      }
    }
    resetRequestFlags();
    setPageStartEnd();
    notify();
  }

  moveFiles() {
    moveCopyFiles(true);
  }

  copyFiles() {
    moveCopyFiles(false);
  }

  notify() {
    p.logR('NotifyListeners called');
    notifyListeners();
  }

  pageDown() {
    currentIndex = start + pageSize;
    setPageStartEnd();
    //p.logF('page down: $start, $end');
    notify();
  }

  pageUp() {
    currentIndex = start - pageSize;
    setPageStartEnd();
    //p.logF('page up: $start, $end');
    notify();
  }

  pxlToggle(value) {
    pxlNames = value;
    notify();
  }

  reInitializeImage(BuildContext context) {
    fileItems[currentIndex].ieImage = null;
    clearImageCache = true;
    notify();
  }

  rename() {
    if (pmNil(newBaseFileName)) return;
    //p.logR('renaming: $newBaseFileName, #${files.length}', level: 1);
    for (int i = 0; i < fileItems.length; i++) {
      String nbn = newBaseFileName;
      if (pxlNames) {
        String name = fileItems[i].name;
        if (pmSubstring(name, len: 4) == 'PXL_') {
          String year = pmSubstring(name, start: 4, len: 4);
          String month = pmSubstring(name, start: 8, len: 2);
          String quarter = '';
          if (month.compareTo('03') <= 0)
            quarter = 'Q1';
          else if (month.compareTo('06') <= 0)
            quarter = 'Q2';
          else if (month.compareTo('09') <= 0)
            quarter = 'Q3';
          else
            quarter = 'Q4';
          nbn = year + '-' + quarter + ' ' + nbn;
        }
      }

      File file = File(fileItems[i].fullPath);
      String newName = nbn + '-' + pmPadNum(baseNumber++, 4) + '.jpg';
      String newFilePath = pmJoinPathToName(currentDirPath, newName);
      p.logR('renaming ${fileItems[i].name} to $newFilePath');
      file.renameSync(newFilePath);
      FileItem nfi = FileItem(newFilePath);
      nfi.thumbnail = fileItems[i].thumbnail;
      fileItems[i] = nfi;
    }
    newBaseFileName = '';
    baseNumber = 0;
    notify();
  }

  resetRequestFlags() {
    numToBeMoved = 0;
    numToBeDeleted = 0;
    for (int i = 0; i < fileItems.length; i++) {
      fileItems[i].thumbsRequested = false;
      if (fileItems[i].toBeDeleted) numToBeDeleted++;
      if (fileItems[i].moveIndex >= 0) numToBeMoved++;
    }
  }

  resize(double factor, Function(double) progressCallback) async {
    double increment = 1.0 / fileItems.length;
    double progress = 0;
    for (int i = 0; i < fileItems.length; i++) {
      File file = File(fileItems[i].fullPath);
      var diBytes = file.readAsBytesSync();
      DI.Image? imageDI = DI.decodeImage(diBytes);
      int width = imageDI!.width;
      int height = imageDI.height;
      int newWidth = (width * factor).floor();
      int newHeight = (height * factor).floor();
      var newDI = DI.copyResize(imageDI, width: newWidth, height: newHeight);
      var data = DI.encodeJpg(newDI);
      var bytes = Uint8List.fromList(data);
      await file.writeAsBytes(bytes);
      if (i < fileItems.length) {
        fileItems[i].width = newWidth;
        fileItems[i].height = newHeight;
        fileItems[i].size = (bytes.length / 1024).floor();
        fileItems[i].ieImage = null;
      }
      progress += increment;
      progressCallback(progress);
    }
  }

  setAndInvokeEditImage(BuildContext context) {
    invokeEditImage() {
      Navigator.pushReplacementNamed(
        context,
        kEditImage,
      );
    }

    FileItem fi = fileItems[currentIndex];
    if (fi.ieImage == null) {
      callback() {
        invokeEditImage();
      }

      currentIEImage = IEImage(fi.fullPath);
      currentIEImage!.initialize(callback);
    } else {
      currentIEImage = fi.ieImage;
      invokeEditImage();
    }
  }

  saveContextAndRoute(BuildContext context, String route) {
    contextAndRoute = {kpmContext: context, kpmRoute: route};
  }

  setFilter(String s) {
    filterString = s.toUpperCase();
    if (pmNotNil(filterString)) {
      String t = '^$filterString.*';
      filter = RegExp(t);
    } else filter = null;
  }

  setAndInvokeDisplayImage(BuildContext context, i) {
    currentIndex = i;
    Navigator.pushReplacementNamed(
      context,
      kDisplayImage,
    );
  }

  setMoveTargets(int j) {
    FileItem fi = fileItems[currentIndex];
    numToBeMoved +=
        fi.setMoveIndex(j); // toggles move index, will return 1 or -1
    notify();
  }

  setNewBaseName(String s) {
    newBaseFileName = s;
    notify();
  }

  setNewBaseNumber(int n) {
    baseNumber = n;
    notify();
  }

  setPageStartEnd() {
    if (currentIndex >= fileItems.length) {
      stopSlideShow();
      currentIndex = fileItems.length - 1;
    }
    currentIndex = checkPageStart(currentIndex);
    start = (currentIndex / pageSize).floor() * pageSize;
    end = checkPageEnd(start + pageSize);
  }

  startSlideShow() {
    slideShowInterval = requestedInterval;
    notify();
  }

  stopSlideShow() {
    slideShowInterval = -1;
    notify();
  }
} // end Model

class FileItem {
  // holds meta data for image files in the directory to be listed
  final PMR p = PMR(className: 'File Item', defaultLevel: 0);

  late File file;
  late String fullPath;
  late String fileName; // with .ext
  int height = 0;
  IEImage? ieImage; // used for annotating image
  late String name; // without .ext
  int moveIndex = -1;
  int isolateRequestStatus =
      -1; // used when requesting thumb from isolate: -1 no thumb request made, 0 request pending, 1 request complete
  int size = 0;
  RawImage? thumbnail;
  bool thumbsRequested = false; // for page starting at this image
  bool toBeDeleted = false;
  int width = 0;

  FileItem(this.fullPath) {
    PMParsePath p = PMParsePath(fullPath);
    name = p.base;
    fileName = p.fileName;
  }

  int setMoveIndex(int j) {
    // used to indicate if file is to be moved, and if so, which directory in moveDirectories
    // returns new value
    if (moveIndex == j) {
      moveIndex = -1;
    } else {
      moveIndex = j;
    }
    return moveIndex >= 0 ? 1 : -1;
  }
} // end FIleItem

class MoveTargets {
  // used to store name of move target directory and its 4 letter moniker
  String newPath;
  late String pathTo;
  String? moniker;
  late Widget display;

  MoveTargets(this.newPath, this.moniker) {
    PMParsePath pp = PMParsePath(newPath);
    pathTo = pp.pathTo;
    if (pmNil(moniker)) {
      // construct moniker if none supplied
      moniker = pmSubstring(pp.base, len: 4).toUpperCase();
    }
    display = pmText(moniker);
  }
} //MoveTargets
